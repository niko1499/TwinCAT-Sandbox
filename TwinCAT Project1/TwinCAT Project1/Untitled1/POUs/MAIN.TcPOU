<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4026.13">
  <POU Name="MAIN" Id="{2619c018-a97e-4e98-bfde-76b022b13f51}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN

VAR
	

	
	bGreenBtn    : POINTER TO BOOL:= ADR(GVL_IO.aInputs[1]);
	bRedBtn		: POINTER TO BOOL:= ADR(GVL_IO.aInputs[2]);
	bLight : POINTER TO BOOL := ADR(GVL_IO.aOutputs[1]);

	fbStartInput : fbDigitalInput(ioBitRef := ADR(GVL_IO.aInputs[1]), switchType := E_SwitchType.NO);
	fbStopInput : fbDigitalInput(ioBitRef := ADR(GVL_IO.aInputs[2]), switchType := E_SwitchType.NC);
	fbLightOutput : fbDigitalOutput(ioBitRef := ADR(GVL_IO.aOutputs[1]), switchType := E_SwitchType.NO);
	light2 : fbDigitalOutput(ioBitRef := ADR(GVL_IO.aOutputs[2]), switchType := E_SwitchType.NO);
	CurrentState: UINT  := TO_UINT(E_LightStates.FAST_BLINK);
	
	fbCounter : CTU;

	timedLight : BOOL;
	timer :TON;

	aLightCurtain : ARRAY[1..10] OF BOOL; 
	
	//myPisa : FB_PISA_Comms(sProductName := 'PISA-M-4CL2');

	cbStates : ARRAY[1..4] OF CircuitBreakerStatus;

	
	
	
	
	myPisa : FB_PISA(eChannelCount := PulsPisaChannelCount.Four, sDeviceName:= 'PULS PISA-M-4CL2');
	i: INT;
	aCurrentStates : ARRAY[1..4] OF CircuitBreakerStatus;
	aTargetStates : ARRAY[1..4] OF CircuitBreakerStatus := [4(CircuitBreakerStatus.UNKNOWN)];
	
	bRun : BOOL :=TRUE;
	bWrite: BOOL :=FALSE;
	status: PisaPulseCommMode;
	
	test: BOOL :=FALSE;
	
	bOnce :BOOL :=FALSE;
	fbFaultChecker : FB_FaultChecker;
	
	bChannelOneTripped:BOOL:=FALSE;
	bDeviceOffline:BOOL:=FALSE;
	fb_eventTrigger1 : FB_EventTrigger(ADR(bChannelOneTripped),
	                       tActivationDelay:=T#2S,
					       nActivationCount:=1,
					   	 //  sErrorName:='Circuit Breaker Tripped',
                          // sErrorDescription:='Lane 1 conveyor motor over current. Check Tension',
    					   eEventCode:=E_MachineStatus.Error); 
						   
						  
	fb_eventTrigger2 : FB_EventTrigger(ADR(bChannelOneTripped),
	                       tActivationDelay:=T#0S,
					       nActivationCount:=3,
					   	   //sErrorName:='Repeat Breaker Trip',
                           //sErrorDescription:='Lane 1 conveyor breaker tripped 3 times.',
    					   eEventCode:=E_MachineStatus.Critical); 
						   
   fb_EventTrigger3 : FB_EventTrigger(ADR(bDeviceOffline),
	                       tActivationDelay:=T#2S,
					       nActivationCount:=1,
					   	   //sErrorName:='Lost Comms with PULSE PISA-M',
                          // sErrorDescription:='Watchdog timer with device expired. Possible wiring issue or loss of power.',
    					   eEventCode:=E_MachineStatus.Warning); 
	
	nLastEventCount: UINT;
	nIndex: INT;
	in:UINT;
	//event: FB_FaultEvent;
	fbMessage : FB_TCMessage;
	bTest2: BOOL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF bOnce THEN
(*
event1:= FB_FaultEvent(bChannelOneTripped,
	                   tActivationDelay:=T#2S,
					   nActivationCount:=1,
					   sErrorName:='Circuit Breaker Tripped',
                       sErrorDescription:='Lane 1 conveyor motor over current. Check Tension',
					   eSeverity:=TcEventSeverity.Error);
*)

fbFaultChecker.AddTrigger(ADR(fb_eventTrigger1));
  fbFaultChecker.AddTrigger(ADR(fb_eventTrigger2));
  fbFaultChecker.AddTrigger(ADR(fb_EventTrigger3));
bOnce := FALSE;
END_IF


(*
IF bChannelOneTripped THEN
	//fbMessage.CreateEx(TC_EVENTS.EventClass.Event,0);
	fbMessage.Create(eventClass:= 
END_IF
*)





fbFaultChecker();//update

myPisa(bEnable:=bRun, bBidirectional:=bWrite);



IF bTest2 THEN
	//myPisa.ResetAll();
ELSE	
//	FOR i := 1 TO 4 DO
//    	myPisa.SetStatus(nChannel:=i , eStatus:=aTargetStates[i]);
//	END_FOR;
END_IF

FOR i := 1 TO 4 DO
    aCurrentStates[i] := myPisa.GetStatus(i);
END_FOR;






status := myPisa.GetCommMode();


bDeviceOffline:=status = PisaPulseCommMode.Offline;

GVL_IO.aOutputs[8] := GVL_IO.aInputs[8]; // Output 8 mirrors input 8





IF fbFaultChecker.GetActiveEventCount()<> nLastEventCount and test THEN

FOR in := 0 TO fbFaultChecker.GetTotalEventCount()-1DO
	//fbFaultChecker.GetEvent(nIndex:=in)^.Active;
	
	
	IF (fbFaultChecker.GetEvent(nIndex:=in)^.Active())THEN 
		ADSLOGSTR(
			msgCtrlMask := ADSLOG_MSGTYPE_HINT, 
			msgFmtStr   := fbFaultChecker.GetEvent(nIndex:=in)^.GetLongMessage(),
			strArg      := '');
	END_IF
END_FOR

(*
ADSLOGSTR(
	msgCtrlMask := ADSLOG_MSGTYPE_HINT, 
	msgFmtStr   := fbFaultChecker.GetFirstActiveEvent()^.GetLongMessage(),
	strArg      := TO_STRING(fbFaultChecker.GetFirstActiveEvent()^.GetEventSeverity())
);


*)      
	nLastEventCount:=fbFaultChecker.GetActiveEventCount();
END_IF





























IF fbStartInput.Get() THEN
		fbLightOutput.Set(TRUE);
ELSE 
		fbLightOutput.Set(FALSE);
END_IF

//bGreenBtn := aInputs[1];


(*
IF bGreenBtn^ THEN
		bLight^:=TRUE;
ELSE 
		bLight^:=FALSE;
END_IF
*)




fbCounter(CU:=fbStartInput.Get(),CU:=fbStartInput.Get(), RESET :=fbStopInput.Get() ,PV := UINT_TO_WORD(E_LightStates.COUNT));
CurrentState:=fbCounter.CV;


	aLightCurtain[1]:= (GVL_IO.flexChain.pdo[GVL_IO.lightBarPDOstartIndex] AND 2#0000_0000_0000_0001) <> 0;
	aLightCurtain[2]:= (GVL_IO.flexChain.pdo[GVL_IO.lightBarPDOstartIndex] AND 2#0000_0000_0000_0010) <> 0;
	aLightCurtain[3]:= (GVL_IO.flexChain.pdo[GVL_IO.lightBarPDOstartIndex] AND 2#0000_0000_0000_0100) <> 0;
	aLightCurtain[4]:= (GVL_IO.flexChain.pdo[GVL_IO.lightBarPDOstartIndex] AND 2#0000_0000_0000_1000) <> 0;
	aLightCurtain[5]:= (GVL_IO.flexChain.pdo[GVL_IO.lightBarPDOstartIndex] AND 2#0000_0000_0001_0000) <> 0;
	aLightCurtain[6]:= (GVL_IO.flexChain.pdo[GVL_IO.lightBarPDOstartIndex] AND 2#0000_0000_0010_0000) <> 0;
	aLightCurtain[7]:= (GVL_IO.flexChain.pdo[GVL_IO.lightBarPDOstartIndex] AND 2#0000_0000_0100_0000) <> 0;
	aLightCurtain[8]:= (GVL_IO.flexChain.pdo[GVL_IO.lightBarPDOstartIndex] AND 2#0000_0000_1000_0000) <> 0;
	aLightCurtain[9]:= (GVL_IO.flexChain.pdo[GVL_IO.lightBarPDOsecondIndex] AND 2#0000_0000_0000_0001) <> 0;
	aLightCurtain[10]:= (GVL_IO.flexChain.pdo[GVL_IO.lightBarPDOsecondIndex] AND 2#0000_0000_0000_0010) <> 0;
								


CASE CurrentState OF
    E_LightStates.OFF:
		fbLightOutput.Set(FALSE);
    E_LightStates.ON:
		fbLightOutput.Set(TRUE);
    E_LightStates.SLOW_BLINK:
		timer(IN := NOT timer.Q, PT := T#1S500MS);
		IF timer.Q THEN 
			timedLight := NOT timedLight; 
		END_IF
		fbLightOutput.Set(timedLight);
    E_LightStates.FAST_BLINK:
		timer(IN := NOT timer.Q, PT := T#0S500MS);
		IF timer.Q THEN 
			timedLight := NOT timedLight; 
		END_IF
		fbLightOutput.Set(timedLight);
ELSE
		fbLightOutput.Set(FALSE);
		fbCounter(RESET:=TRUE);
		
END_CASE

IF GVL_IO.Encoder_Counts > 500 THEN
	light2.Set(TRUE);
ELSE
	light2.Set(FALSE);		

END_IF

]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>