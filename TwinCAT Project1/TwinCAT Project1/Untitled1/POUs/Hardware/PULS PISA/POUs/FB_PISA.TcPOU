<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.15">
  <POU Name="FB_PISA" Id="{4f444559-2ec0-4ae1-95ff-f2b379ef25de}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_PISA
VAR_INPUT
	 bEnable	: BOOL; //When TRUE devices channel states will be read from device and stored for retreval by GetSatus()
	 bBidirectional	: BOOL; //When TRUE and bEnable target channel states as configured by SetStatus() will be sent to the device 
END_VAR
VAR CONSTANT
	//Constants as defined in Pulse Pisa Manuals
    MAX_NUMBER_OF_CHANNELS : USINT            := 8; //Theoritical max channels offered by Pulse is 64. Setting to 8 for now as we are unlikely to go beyond 8
	STANDARD_NUMBER_OF_CHANNELS : USINT       := 4;  
	
	SHORT_START_PULSE_DURATION : TIME := T#150MS;
	LONG_START_PULSE_DURATION : TIME  := T#200MS;
	
	DRIFT_TOLERANCE : TIME        := T#15MS;
	STATUS_DURATION: TIME         := T#100MS;
	STATUS_PERIOD_DURATION: TIME  := T#200MS;
	
	FOUR_CHANNEL_SEQUENCE_TIME :TIME := T#1100MS;
	EIGHT_CHANNEL_SEQUENCE_TIME :TIME := T#2200MS;
	
	WRITE_PERIODS_AFTER_DATA : USINT :=2;
	
	MIN_PULSE_DURATION: TIME     := T#50MS;	
	
END_VAR

VAR
	PisaIO : PISA_IO; // Struct for mapping PLC to physical IO Hardware
	PisaHMI : PISA_HMI; //Struct for mapping PLC to HMI
	
	lastPisaHMI : PISA_HMI; //Struct for latching states
	
	tWatchdogTime: TIME;
	timerReadSequenceWatchdog : TOF;
	
	bWriteRequestedHMI : BOOL;

	
	bStartBitFound : BOOL;//Indicateds the falling edge of the start bit has been found. (we are reading channels)
	nReadingChannelIndex	: USINT := 0 ; //The current channel number as determined by time or falling edges in the data
	nLastReadingChannelIndex :USINT :=0; //A lag behind value of the channel for correct array index because saving of channel data happends in the first time slice of the next channel 
	nNumberOfChannels : USINT := STANDARD_NUMBER_OF_CHANNELS;
	tLastPulseDuration : TIME; //Store the elapsed time. 
	
	timerPulseMeasurement :TON;
	timerReadPeriodMax : TP;
	timerPeriodMin :TON;
		
	inputFallingEdge: F_TRIG;
	maxTime: F_TRIG;//Indicates the maximum time of a channel has been hit
	bResetMaxTimeFlag: BOOL:=FALSE; //Used to indicate the max pulse timer needs to be reset NEXT cycle. Can't happen this cycle or Q will not trigger. 

	//Variables for Writing
	aCtrl : ARRAY[0..MAX_NUMBER_OF_CHANNELS+WRITE_PERIODS_AFTER_DATA] OF TimedPulse:= [(MAX_NUMBER_OF_CHANNELS+WRITE_PERIODS_AFTER_DATA)(sOnSignal)];
		
	timerLeadingGap : NTP; //TODO-NIKO See if this can be better rewritten to no use my strange extended timer. Or clean up the timer. should add unit test first as changing it breaks functionality currently
	timerWriteHigh : NTP;
	timerTrailingGap: NTP;
	
	fTimer1Done : F_TRIG;
	fTimer2Done : F_TRIG;
	fTimer3Done : F_TRIG;

	nNextWriteChannelFlag : BOOL:=TRUE;
	nWriteIndex : USINT;

	nDoneCount:USINT:=0;	
	nTimersToComplete: USINT :=0;

	//Command Durations	
	tGapTimeAdjustment :TIME:=T#5MS; //Needed to account for drift due to syscle time
    sStartBitSignal : TimedPulse := (tLeadingGap := T#000MS, tHighSignal := T#150MS, tTrailingGap := T#000MS);
	sResetSignal    : TimedPulse := (tLeadingGap := T#100MS - tGapTimeAdjustment, tHighSignal := T#100MS, tTrailingGap := T#000MS);
	sOnSignal       : TimedPulse := (tLeadingGap := T#200MS - tGapTimeAdjustment, tHighSignal := T#000MS, tTrailingGap := T#000MS);
	sOffSignal      : TimedPulse := (tLeadingGap := T#100MS - tGapTimeAdjustment, tHighSignal := T#050MS, tTrailingGap := T#050MS);
	sStopBitSignal  : TimedPulse := (tLeadingGap := T#100MS, tHighSignal :=T#100MS, tTrailingGap := T#050MS);
	sWaitBitSignal  : TimedPulse := (tLeadingGap := T#500MS, tHighSignal := T#000MS, tTrailingGap := T#000MS);
	
	nResetChannel :USINT:=1;
	
	timerResetDelay : TON;

	

	i: INT;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*
//*****************************************************************Notes**********************************************************\\
Function Block for reading and writing channel states to PULS PISA line of smart circuit breaker products.
https://products.pulspower.com/us/product-families/pisa.html

Implemented and tested at 2MS Cycle Time. Different Cycle times could cause communication issues with device. 
10MS cycle time may be suficient for reading but the software on the PISA-M will not interpret written signals correctly at +/-10MS
Code was written with to accomidate for different numbers of device channels but has only been tested with the the 4 channel PISA-M-4CL2
 
//*****************************************************************Revs**********************************************************\\
   (          who            )(    Date    ) (   Rev     ) (								Disc						)
     Nikolas Gamarra		 	2025.09.26		1.0.0		Initial Code
	
//*****************************************************************Code**********************************************************\\
*)
IF bEnable THEN
	
	ReadFromDevice();
	
	bWriteRequestedHMI:=FALSE;
	
	
	
	
	

	
	
	IF bBidirectional THEN
		
	
		FOR i := 1 TO nNumberOfChannels DO
		IF PisaHMI.aStatus[i] = CircuitBreakerStatus.OFF AND lastPisaHMI.aStatus[i] = CircuitBreakerStatus.ON AND PisaHMI.aTargetStatus[i] = CircuitBreakerStatus.ON THEN
			PisaHMI.aTargetStatus[i] := CircuitBreakerStatus.OFF; 
		END_IF
		IF PisaHMI.aStatus[i] = CircuitBreakerStatus.ON AND lastPisaHMI.aStatus[i] = CircuitBreakerStatus.OFF AND PisaHMI.aTargetStatus[i] = CircuitBreakerStatus.OFF THEN
			PisaHMI.aTargetStatus[i] := CircuitBreakerStatus.ON; 
		END_IF
		
		IF PisaHMI.aStatus[i] = lastPisaHMI.aStatus[i] AND PisaHMI.aTargetStatus[i] <> lastPisaHMI.aTargetStatus[i] THEN
			bWriteRequestedHMI:=TRUE;
		END_IF
		
		
	END_FOR
	
		
		WriteToDevice();
	ELSE
		ResetWriteIndex();
		CopyReadValuesToTargetValues();
	END_IF	
	
	lastPisaHMI:= PisaHMI;
ELSE// Program not running.
	ClearStatus();
	ClearTarget();
END_IF

]]></ST>
    </Implementation>
    <Method Name="ClearStatus" Id="{c2593c16-d99c-4daa-8d6d-31e081e3bd02}">
      <Declaration><![CDATA[METHOD PRIVATE ClearStatus
VAR_INPUT
END_VAR
VAR
	i : INT;//array index
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i := 1 TO nNumberOfChannels DO
	// Wipe out the array. 	
	PisaHMI.aStatus[i] := CircuitBreakerStatus.UNKNOWN; 
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="ClearTarget" Id="{056b04ad-0cba-4a42-9842-3c6fc7d5d2d9}">
      <Declaration><![CDATA[METHOD PRIVATE ClearTarget
VAR_INPUT
END_VAR

VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i := 1 TO nNumberOfChannels DO
	// Wipe out the array 	
	PisaHMI.aTargetStatus[i] := CircuitBreakerStatus.UNKNOWN;
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="CopyReadValuesToTargetValues" Id="{746303db-488c-4952-bef7-643ffbbe8489}">
      <Declaration><![CDATA[METHOD PRIVATE CopyReadValuesToTargetValues
VAR_INPUT
END_VAR

VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i := 1 TO nNumberOfChannels DO
    PisaHMI.aTargetStatus[i] := PisaHMI.aStatus[i];
END_FOR;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{2d3d76f7-d971-465d-887e-139ba32ec4e4}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
	eChannelCount : PulsPisaChannelCount;// Number of independent circuit breaker channels on the device
	sDeviceName: STRING;// Name of the device for reference later when building error messages
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[aCtrl[0]:=sStartBitSignal;
aCtrl[nNumberOfChannels+1]:=sStopBitSignal;
nNumberOfChannels := TO_USINT(eChannelCount);

PisaIO.sProductName:=sDeviceName;

IF eChannelCount = PulsPisaChannelCount.Eight THEN
	tWatchdogTime:=EIGHT_CHANNEL_SEQUENCE_TIME ;
ELSE
	tWatchdogTime:=FOUR_CHANNEL_SEQUENCE_TIME ;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetChannelCount" Id="{666ac572-b6c3-45bd-8f99-318cdf412080}">
      <Declaration><![CDATA[METHOD PUBLIC GetChannelCount : USINT
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[GetChannelCount := nNumberOfChannels;]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetCommMode" Id="{37f9f250-a55e-4c66-b009-79b3c19a10ff}">
      <Declaration><![CDATA[METHOD PUBLIC GetCommMode : PisaPulseCommMode //The current operational mode of the device
]]></Declaration>
      <Implementation>
        <ST><![CDATA[GetCommMode:=PisaHMI.sCommMode;]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetDeviceName" Id="{fe63e2b7-aa16-4b13-9efd-81248147d12f}">
      <Declaration><![CDATA[METHOD PUBLIC GetDeviceName : STRING
]]></Declaration>
      <Implementation>
        <ST><![CDATA[GetDeviceName:=PisaIO.sProductName;]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetStatus" Id="{59102917-1316-4021-9562-94498880e7f9}">
      <Declaration><![CDATA[METHOD GetStatus : CircuitBreakerStatus // The state of provided channel
VAR_INPUT
	nChannel : UINT; // The device channel to check the state of
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF nChannel > 0 AND nChannel <= nNumberOfChannels THEN
	GetStatus := PisaHMI.aStatus[nChannel];
ELSE
	GetStatus := CircuitBreakerStatus.UNKNOWN;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="ReadFromDevice" Id="{e97ff11f-cce5-446a-8eba-233730ac13f1}">
      <Declaration><![CDATA[METHOD PRIVATE ReadFromDevice : BOOL
VAR_INPUT
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[timerPulseMeasurement(IN := PisaIO.bRX , PT:=tWatchdogTime);
	

inputFallingEdge(CLK := PisaIO.bRX);//Indicates any falling edge on the input signal 
maxTime(CLK:= timerReadPeriodMax.Q);//Indicates the max period time has elapsed

IF bResetMaxTimeFlag THEN
	timerReadPeriodMax(IN:=TRUE);
	bResetMaxTimeFlag :=FALSE;
ELSE
	timerReadPeriodMax(IN:=inputFallingEdge.Q AND NOT timerReadPeriodMax.Q, PT:= STATUS_PERIOD_DURATION);
END_IF

IF( PisaIO.bRX = TRUE AND NOT inputFallingEdge.Q AND NOT timerPulseMeasurement.Q) THEN // IF the input is high, update the running counter of the pulse duration
	tLastPulseDuration := timerPulseMeasurement.ET;	
END_IF

timerReadSequenceWatchdog(IN := inputFallingEdge.Q, PT:= tWatchdogTime);

IF (timerReadSequenceWatchdog.Q = FALSE) THEN//Our watchdog has expired
	PisaHMI.sCommMode := PisaPulseCommMode.Offline;	
	ClearStatus();
END_IF

IF (inputFallingEdge.Q)THEN //A pulse just completed

	
	IF tLastPulseDuration >= SHORT_START_PULSE_DURATION - DRIFT_TOLERANCE THEN
		IF tLastPulseDuration >= T#155MS(*LONG_START_PULSE_DURATION - DRIFT_TOLERANCE THEN*) THEN
			PisaHMI.sCommMode := PisaPulseCommMode.Unidirectional;
		ELSE
			PisaHMI.sCommMode := PisaPulseCommMode.Bidirectional;
		END_IF
		
		bStartBitFound 	:= NOT bStartBitFound; // Main reset happens elsewhere. Failsafe here. Only happense every other cycle but acceptable as only a failsafe.
		ResetReadIndex();//Reset counter to prepair for next cycle 
		tLastPulseDuration :=T#0MS ;// reset the time counter so we can measure next pulses
		
	END_IF
END_IF

IF (((maxTime.Q = TRUE AND PisaIO.bRX = FALSE )) AND bStartBitFound = TRUE) THEN 
	IF timerPeriodMin.Q THEN
		nReadingChannelIndex := nReadingChannelIndex + 1;
		timerPeriodMin(IN:= FALSE, PT:=DRIFT_TOLERANCE);
	END_IF 
ELSE
	timerPeriodMin(IN:= TRUE, PT:=DRIFT_TOLERANCE);			
END_IF

IF bStartBitFound THEN // Only calculate state if we have found the start bit and thus are in the channel bits
	IF (nLastReadingChannelIndex <> nReadingChannelIndex) THEN//We have advanced to the gap period after a readin of a pulse
		
		bResetMaxTimeFlag:=TRUE;

		IF tLastPulseDuration >= DRIFT_TOLERANCE THEN //have a positive signal
			IF tLastPulseDuration >= MIN_PULSE_DURATION - DRIFT_TOLERANCE THEN //Signal large enough than smallest expected
				IF tLastPulseDuration > STATUS_DURATION - DRIFT_TOLERANCE THEN
					PisaHMI.aStatus[nLastReadingChannelIndex]	:= CircuitBreakerStatus.TRIPPED;
				ELSIF tLastPulseDuration > MIN_PULSE_DURATION - DRIFT_TOLERANCE THEN
					PisaHMI.aStatus[nLastReadingChannelIndex]	:= CircuitBreakerStatus.OFF;
				ELSE //should never happen
					ClearStatus();
				END_IF	
			ELSE//Likely indicates out of sync
				ClearStatus();
			END_IF
		ELSE
			IF PisaHMI.sCommMode = PisaPulseCommMode.Bidirectional THEN	
				PisaHMI.aStatus[nLastReadingChannelIndex]	:= CircuitBreakerStatus.ON;
			ELSE
				PisaHMI.aStatus[nLastReadingChannelIndex]	:= CircuitBreakerStatus.NOTTRIPPED;
			END_IF
		END_IF
				
		tLastPulseDuration :=T#0MS ;// reset the time counter as we have recorded the measurement for this pulse
		nLastReadingChannelIndex := nReadingChannelIndex;
	END_IF

	IF nReadingChannelIndex > nNumberOfChannels THEN //End of Sequence
		bStartBitFound := FALSE;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResetAll" Id="{057b81b1-2031-4845-a666-ab49e9cb1dd9}">
      <Declaration><![CDATA[METHOD PRIVATE ResetAll // Sequencial rolling reseet of all channels
]]></Declaration>
      <Implementation>
        <ST><![CDATA[timerResetDelay(IN:= NOT timerResetDelay.Q,PT:=tWatchdogTime );

IF timerResetDelay.Q THEN
	nResetChannel :=nResetChannel+1;
END_IF

//Perform a rolling reseet of all channels. (off by 1 index is ok a setter rejects out of bounds args)
SetStatus(nChannel:=nResetChannel, eStatus:=CircuitBreakerStatus.RESET);
SetStatus(nChannel:=nResetChannel-1, eStatus:=CircuitBreakerStatus.ON);


IF nResetChannel > nNumberOfChannels THEN
	nResetChannel:=1;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResetReadIndex" Id="{ad198e60-facd-476c-ae58-d4ab1425a705}">
      <Declaration><![CDATA[METHOD PRIVATE ResetReadIndex

]]></Declaration>
      <Implementation>
        <ST><![CDATA[nReadingChannelIndex :=1;
nLastReadingChannelIndex:=1;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResetWriteIndex" Id="{571a19b9-e199-4130-b85a-8069619966bb}">
      <Declaration><![CDATA[METHOD PRIVATE ResetWriteIndex
]]></Declaration>
      <Implementation>
        <ST><![CDATA[PisaIO.bTX:=FALSE;
nNextWriteChannelFlag:=TRUE;
nWriteIndex:=0;	
aCtrl[0]:=sStartBitSignal;
aCtrl[nNumberOfChannels+1]:=sStopBitSignal;
aCtrl[nNumberOfChannels+2]:=sWaitBitSignal;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetStatus" Id="{2125d974-d757-45e0-8c5c-dfe0fcf3a766}">
      <Declaration><![CDATA[METHOD SetStatus
VAR_INPUT
	nChannel : UINT; // The device channel to change
	eStatus : CircuitBreakerStatus; // The desired stat to change to
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF nChannel >0 AND nChannel<=nNumberOfChannels THEN
	PisaHMI.aTargetStatus[nChannel]:=eStatus;//Actual settingof the desired status to device
	IF (PisaHMI.aStatus[nChannel] <> CircuitBreakerStatus.ON)THEN//Fake a status of reset but only if the device hasn't yet successfully reset
		IF(eStatus = CircuitBreakerStatus.RESET AND PisaHMI.sCommMode =  PisaPulseCommMode.Bidirectional)  THEN
			PisaHMI.aStatus[nChannel] := CircuitBreakerStatus.RESET;
		END_IF
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="WriteToDevice" Id="{92b20edd-1a08-454e-8ce5-bd3db832b2ec}">
      <Declaration><![CDATA[METHOD PRIVATE WriteToDevice : BOOL
VAR_INPUT
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF nNextWriteChannelFlag THEN
	nTimersToComplete:=0;
	IF(aCtrl[nWriteIndex].tLeadingGap > T#0MS)THEN
		nTimersToComplete:=nTimersToComplete+1;
	END_IF
	IF(aCtrl[nWriteIndex].tHighSignal > T#0MS)THEN
		nTimersToComplete:=nTimersToComplete+1;
	END_IF
	IF(aCtrl[nWriteIndex].tTrailingGap > T#0MS)THEN
		nTimersToComplete:=nTimersToComplete+1;
	END_IF
END_IF

timerLeadingGap(IN:=nNextWriteChannelFlag, PT:=aCtrl[nWriteIndex].tLeadingGap);
timerWriteHigh(IN:= NOT timerLeadingGap.Q AND NOT nNextWriteChannelFlag, PT:=aCtrl[nWriteIndex].tHighSignal);
timerTrailingGap(IN:= NOT timerWriteHigh.Q AND NOT timerWriteHigh.Q AND NOT nNextWriteChannelFlag AND nDoneCount>0, PT:=aCtrl[nWriteIndex].tTrailingGap);

fTimer1Done(CLK:= timerLeadingGap.Q);
fTimer2Done(CLK:= timerWriteHigh.Q);
fTimer3Done(CLK:= timerTrailingGap.Q);


IF (fTimer1Done.Q OR  fTimer2Done.Q OR fTimer3Done.Q)AND NOT nNextWriteChannelFlag THEN
	nDoneCount := nDoneCount +1;
END_IF


nNextWriteChannelFlag:=FALSE;
IF nDoneCount >= nTimersToComplete  THEN

	nDoneCount:=0;
	nWriteIndex := nWriteIndex + 1;
	nNextWriteChannelFlag:=TRUE;
	
	
	IF(nWriteIndex>0 AND nWriteIndex <nNumberOfChannels+1) THEN
		//Update any target values. Won't execute till next cycle
		CASE PisaHMI.aTargetStatus[nWriteIndex] OF 
		CircuitBreakerStatus.OFF, CircuitBreakerStatus.TRIPPED:
			aCtrl[nWriteIndex]:=sOffSignal;
		CircuitBreakerStatus.On, CircuitBreakerStatus.NOTTRIPPED:
			aCtrl[nWriteIndex]:=sOnSignal;
		CircuitBreakerStatus.RESET :
			aCtrl[nWriteIndex]:=sResetSignal;
		ELSE // Default (UNKNOWN)
			//replace the unknown with the read value
			PisaHMI.aTargetStatus[nWriteIndex] := PisaHMI.aStatus[nWriteIndex];
			//repeat this step
			nDoneCount:=99;
			nWriteIndex:=nWriteIndex-1;
			
			
			//aCtrl[nWriteIndex]:=sOnSignal;
		END_CASE;
	END_IF	
END_IF

IF(nWriteIndex >nNumberOfChannels + WRITE_PERIODS_AFTER_DATA) THEN  
		ResetWriteIndex();
END_IF

PisaIO.bTX:=timerWriteHigh.Q;//Write to digital output]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>