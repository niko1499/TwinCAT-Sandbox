<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.15">
  <POU Name="FB_PISA_Comms" Id="{fcd1d659-8ade-4890-bc41-6e29b3b0778a}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_PISA_Comms
VAR_INPUT
	 bStart	: BOOL;
	//bReset	: BOOL;
	//biDirectional	: BOOL;
END_VAR
VAR CONSTANT
	//Constants as defined in Pulse Pisa Manuals
    cMaxChannels : INT := 64;
	cStandardChannels : UINT :=4;
	cMaxPulseDuration :TIME :=T#200MS;
	cShortStartPulseDuration : TIME := T#150MS;
	cLongStartPulseDuration : TIME := T#200MS;
	cGapTime : TIME :=T#100MS;
	cStatusTime: TIME:=T#100MS;
	cPeriodTime: TIME:= T#190MS;//gapTime + statusTime; SHOULD BE 200
	cMinimumPeriodTime:TIME:=T#60MS;
	cOffTime :TIME :=T#50MS;
	//Constants of our PLC
	cCycleTime : TIME := T#10MS;//TODO update this programatically on FB init.
	cTolerance : TIME := T#20ms;//cCycleTime *2;
END_VAR

VAR
	PisaIO : PISA_Comms; // Struct for mapping to the actual IO Hardware
	
	//bStart : BOOL := TRUE;//TODO use or delete
	biDirectional : BOOL := FALSE;//TODO get bidirectional status from device by measuring start bit length
	
	
	
	nNumberOfDeviceChannels : UINT :=cStandardChannels;//TODO set this between 4-64 on Init. Possibly based on device name as digit in device name indicates channels 
	
	bStartBitFound : BOOL;//Indicateds the falling edge of the start bit has been found. (we are reading channels)
	tStartTimeDuration	: TIME ; // The expected start bit udration variable based on bi or uni directional communication. 
	nChannelNumber	: USINT := 0 ; //The current channel number as determined by time or falling edges in the data
	nLastChannelNumber :USINT :=0; //A lag behind value of the channel for correct array index because saving of channel data happends in the first time slice of the next channel 

	aStatus : ARRAY[1..cMaxChannels] OF CircuitBreakerStatus := [cMaxChannels(CircuitBreakerStatus.UNKNOWN)];


	tPulseMeasurementTimer :TON;
	mostRecientTime : TIME; //Store the elapsed time. 


	
	
	PeriodMaxTimeTimer : TP;
	PeriodMinTimeTimer :TON;
	
	
	
	inputFallingEdge: F_TRIG;
	maxTime: F_TRIG;//Indicates the maximum time of a channel has been hit
	resetQFlag: BOOL:=FALSE; //Used to indicate the max pulse timer needs to be reset NEXT cycle. Can't happen this cycle or Q will not trigger. 

END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF bStart THEN

	IF biDirectional THEN
		tStartTimeDuration	:= cShortStartPulseDuration;
	ELSE
		tStartTimeDuration	:= cLongStartPulseDuration;
	END_IF
	
	tPulseMeasurementTimer(IN := PisaIO.bRX , PT:=tStartTimeDuration+cTolerance);
	
	inputFallingEdge(CLK := PisaIO.bRX);//Indicates any falling edge on the input signal 
	maxTime(CLK:= PeriodMaxTimeTimer.Q);//Indicates the max period time has elapsed
	
	IF resetQFlag THEN
		PeriodMaxTimeTimer(IN:=TRUE);
		resetQFlag :=FALSE;
	ELSE
		PeriodMaxTimeTimer(IN:=inputFallingEdge.Q AND NOT PeriodMaxTimeTimer.Q, PT:= cPeriodTime);
	END_IF
	
	
	
	IF( PisaIO.bRX = TRUE AND NOT inputFallingEdge.Q AND NOT tPulseMeasurementTimer.Q) THEN // IF the input is high, update the running counter of the pulse duration
		mostRecientTime := tPulseMeasurementTimer.ET;	
	END_IF
	
	IF (inputFallingEdge.Q)THEN //A pulse just completed
		PeriodMaxTimeTimer(IN:=FALSE);//End of period triggers end of time counter resets time to 0 
		
		IF mostRecientTime >= cShortStartPulseDuration - cTolerance THEN
			bStartBitFound 	:= NOT bStartBitFound; // Will only read every other start bit but simplifies some logice and time syncing
			mostRecientTime :=T#0MS ;// reset the time counter so we can measure non pulses
			
		END_IF
		//PeriodMaxTimeTimer(IN:=TRUE);
	ELSE
		//PeriodMaxTimeTimer(IN:=TRUE);	
	END_IF
	
	IF ((inputFallingEdge.Q = TRUE OR maxTime.Q = TRUE) AND bStartBitFound = TRUE) THEN
		IF PeriodMinTimeTimer.Q THEN
			nChannelNumber := nChannelNumber + 1;
			PeriodMinTimeTimer(IN:= FALSE, PT:=cTolerance);
		END_IF 
	ELSE
		PeriodMinTimeTimer(IN:= TRUE, PT:=cTolerance);			
	END_IF
	
	IF bStartBitFound THEN // Only calculate state if we have found the start bit and thus are in the channel bits
		IF (nLastChannelNumber <> nChannelNumber) THEN//We have advanced to the gap period after a readin of a pulse
			resetQFlag:=TRUE;
			IF nChannelNumber > 0 THEN
				IF mostRecientTime > cCycleTime AND mostRecientTime <= cOffTime + cCycleTime THEN
					aStatus[nLastChannelNumber]	:= CircuitBreakerStatus.OFF;
				ELSIF mostRecientTime > cOffTime THEN
					aStatus[nLastChannelNumber]	:= CircuitBreakerStatus.Tripped;
				ELSE
					aStatus[nLastChannelNumber]	:= CircuitBreakerStatus.ON;
				END_IF
			END_IF
			mostRecientTime :=T#0MS ;// reset the time counter as we have recorded the measurement for this pulse
			nLastChannelNumber := nChannelNumber;
		END_IF
	
		IF nChannelNumber > cStandardChannels THEN //End of Sequence
			bStartBitFound := FALSE;
			nChannelNumber :=0;
		END_IF
	ELSE//!StartBitFound
		IF nChannelNumber > 0 THEN//We do not expect to ever be in this state. Indicates the channel number stalled. Likely due to a timer failing to reset;
			ClearStoredValues();
		END_IF
	END_IF
ELSE
	ClearStoredValues();
END_IF]]></ST>
    </Implementation>
    <Method Name="ClearStoredValues" Id="{8c872f6e-f6ce-4ed1-8772-ffa97afe5b3d}">
      <Declaration><![CDATA[METHOD PRIVATE ClearStoredValues
VAR_INPUT
END_VAR
VAR
	i : INT;//array index
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i := 1 TO nNumberOfDeviceChannels DO
	aStatus[i] := CircuitBreakerStatus.UNKNOWN; // Wipe out the array as we are in an unexpected state so no recorded values are guarenteed to be correct. 
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{111f2d93-df1c-4131-8042-2161ba29b6b2}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
	//sProductName : STRING;
END_VAR

VAR
	cChar: STRING;
	iDigit: UINT;
	iIndex: INT;
	sMyString: INT;
	iMyInteger: INT;
	exc : __SYSTEM.ExceptionCode;

END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//PisaIO.sProductName := sProductName;
(*
__TRY
nNumberOfDeviceChannels := STRING_TO_UINT(MID(sProductName,1,4));
__CATCH(exc)
	//TODO Throw exception with indication of unexpected character in 4th digit of product name
__ENDTRY
*)
//PISA-M-404
//PISA-M-%i0%j
//Pisa modules follow the following naming convention where %i is the number of channels and %j is the amperage

//nNumberOfDeviceChannels := iDigit;]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetStatus" Id="{b627c613-9025-44cd-970a-bd5106ddd8b2}">
      <Declaration><![CDATA[METHOD GetStatus : CircuitBreakerStatus
VAR_INPUT
	nChannel : UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF nChannel > 0 AND nChannel <= nNumberOfDeviceChannels THEN
	GetStatus := aStatus[nChannel];
ELSE
	//todo error
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetStatus" Id="{6642a64a-4e50-4f13-b203-f745ad1ed55d}">
      <Declaration><![CDATA[METHOD SetStatus
VAR_INPUT
	nChannel : UINT;
	sStatus : CircuitBreakerStatus;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF(sStatus = CircuitBreakerStatus.ON OR sStatus = CircuitBreakerStatus.RESET) THEN
	aStatus[nChannel] := CircuitBreakerStatus.RESET;
END_IF

//TODO logic to transmit reset signals or off signal]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>