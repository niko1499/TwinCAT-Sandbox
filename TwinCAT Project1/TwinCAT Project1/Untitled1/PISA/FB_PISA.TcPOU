<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.15">
  <POU Name="FB_PISA" Id="{fcd1d659-8ade-4890-bc41-6e29b3b0778a}" SpecialFunc="None">
    <Declaration><![CDATA[//---NOTE---
//IMPLEMENTED AND TESTED at 2MS Cycle Time. Different Cycle times could cause communication issues with device. 
FUNCTION_BLOCK FB_PISA
VAR_INPUT
	 bStart	: BOOL;
	 bBidirectional	: BOOL;
END_VAR
VAR CONSTANT
	//Constants as defined in Pulse Pisa Manuals
    MAX_NUMBER_OF_CHANNELS : USINT            := 8; //Theoritical max channels offered by Pulse is 64. Setting to 8 for now as we are unlikely to go beyond 8
	STANDARD_NUMBER_OF_CHANNELS : USINT       := 4;  
	
	SHORT_START_PULSE_DURATION : TIME := T#150MS;
	LONG_START_PULSE_DURATION : TIME  := T#200MS;
	
	DRIFT_TOLERANCE : TIME        := T#15MS;
	STATUS_DURATION: TIME         := T#100MS;
	STATUS_PERIOD_DURATION: TIME  := T#200MS;
	
	FOUR_CHANNEL_SEQUENCE_TIME :TIME := T#1100MS;
	EIGHT_CHANNEL_SEQUENCE_TIME :TIME := T#2200MS;
	
	WRITE_PERIODS_AFTER_DATA : USINT :=2;
	
	MIN_PULSE_DURATION: TIME     := T#50MS;	
	
END_VAR

VAR
	PisaIO : PISA_IO; // Struct for mapping to the actual IO Hardware
	tWatchdogTime: TIME;
	timerReadSequenceWatchdog : TOF;
	
	commMode : PisaPulseCommMode := PisaPulseCommMode.Offline;	
	//Variables for Reading
	aStatus : ARRAY[1..MAX_NUMBER_OF_CHANNELS] OF CircuitBreakerStatus := [MAX_NUMBER_OF_CHANNELS(CircuitBreakerStatus.UNKNOWN)];
	aTargetStatus : ARRAY[1..MAX_NUMBER_OF_CHANNELS] OF CircuitBreakerStatus := [MAX_NUMBER_OF_CHANNELS(CircuitBreakerStatus.UNKNOWN)];
	
	bStartBitFound : BOOL;//Indicateds the falling edge of the start bit has been found. (we are reading channels)
	nReadingChannelIndex	: USINT := 0 ; //The current channel number as determined by time or falling edges in the data
	nLastReadingChannelIndex :USINT :=0; //A lag behind value of the channel for correct array index because saving of channel data happends in the first time slice of the next channel 
	nNumberOfChannels : USINT := STANDARD_NUMBER_OF_CHANNELS;
	tLastPulseDuration : TIME; //Store the elapsed time. 
	
	timerPulseMeasurement :TON;
	timerReadPeriodMax : TP;
	timerPeriodMin :TON;
		
	inputFallingEdge: F_TRIG;
	maxTime: F_TRIG;//Indicates the maximum time of a channel has been hit
	bResetMaxTimeFlag: BOOL:=FALSE; //Used to indicate the max pulse timer needs to be reset NEXT cycle. Can't happen this cycle or Q will not trigger. 

	//Variables for Writing
	aCtrl : ARRAY[0..MAX_NUMBER_OF_CHANNELS+WRITE_PERIODS_AFTER_DATA] OF PULSE:= [(MAX_NUMBER_OF_CHANNELS+WRITE_PERIODS_AFTER_DATA)(sOnSignal)];
		
	timerLeadingGap : NTP; //TODO-NIKO See if this can be better rewritten to no use my strange extended timer. Or clean up the timer. should add unit test first as changing it breaks functionality currently
	timerWriteHigh : NTP;
	timerTrailingGap: NTP;
	
	fTimer1Done : F_TRIG;
	fTimer2Done : F_TRIG;
	fTimer3Done : F_TRIG;

	nNextWriteChannelFlag : BOOL:=TRUE;
	nWriteIndex : USINT;

	nDoneCount:USINT:=0;	
	nTimersToComplete: USINT :=0;

	//Command Durations	
	tGapTimeAdjustment :TIME:=T#5MS; //Needed to account for drift due to syscle time
    sStartBitSignal : PULSE := (tLeadingGap := T#000MS, tHighSignal := T#150MS, tTrailingGap := T#000MS);
	sResetSignal    : PULSE := (tLeadingGap := T#100MS - tGapTimeAdjustment, tHighSignal := T#100MS, tTrailingGap := T#000MS);
	sOnSignal       : PULSE := (tLeadingGap := T#200MS - tGapTimeAdjustment, tHighSignal := T#000MS, tTrailingGap := T#000MS);
	sOffSignal      : PULSE := (tLeadingGap := T#100MS - tGapTimeAdjustment, tHighSignal := T#050MS, tTrailingGap := T#050MS);
	sStopBitSignal  : PULSE := (tLeadingGap := T#100MS, tHighSignal :=T#100MS, tTrailingGap := T#050MS);
	sWaitBitSignal  : PULSE := (tLeadingGap := T#500MS, tHighSignal := T#000MS, tTrailingGap := T#000MS);
	
	nResetChannel :USINT:=1;
	
	timerResetDelay : TON;

	
	bBidirectionalRequested: BOOL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF bStart THEN
	
	bBidirectionalRequested:=bBidirectional;
	ReadFromDevice();
	
	IF bBidirectionalRequested THEN
		WriteToDevice();
	ELSE
		ResetWriteIndex();
	END_IF	
ELSE// Program not running.
	ClearStoredValues();
END_IF]]></ST>
    </Implementation>
    <Method Name="CalculateWiteBitDuration" Id="{521a4c92-6139-4c79-bb7e-22d786562bc0}">
      <Declaration><![CDATA[METHOD PRIVATE CalculateWiteBitDuration : TIME
VAR_INPUT
	nStartBit:USINT;
	nEndBit :USINT;
END_VAR

VAR
	i: INT;
	tRunningTotal:TIME:=T#0MS;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i := nStartBit TO nEndBit DO
    tRunningTotal:=tRunningTotal + aCtrl[i].tLeadingGap + aCtrl[i].tHighSignal;
END_FOR;

CalculateWiteBitDuration:=tRunningTotal;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="ClearStoredValues" Id="{8c872f6e-f6ce-4ed1-8772-ffa97afe5b3d}">
      <Declaration><![CDATA[METHOD PRIVATE ClearStoredValues
VAR_INPUT
END_VAR
VAR
	i : INT;//array index
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i := 1 TO nNumberOfChannels DO
	aStatus[i] := CircuitBreakerStatus.UNKNOWN; // Wipe out the array as we are in an unexpected state so no recorded values are guarenteed to be correct. 
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{9b52ece2-d8dc-409f-8275-86ed0ed48b59}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
	eChannelCount : PulsPisaChannelCount;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[aCtrl[0]:=sStartBitSignal;
aCtrl[nNumberOfChannels+1]:=sStopBitSignal;
nNumberOfChannels := TO_USINT(eChannelCount);

IF eChannelCount = PulsPisaChannelCount.Eight THEN
	tWatchdogTime:=EIGHT_CHANNEL_SEQUENCE_TIME ;
ELSE
	tWatchdogTime:=FOUR_CHANNEL_SEQUENCE_TIME ;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetCommMode" Id="{0c35d0de-ab17-4237-a989-bcb0a8d52a88}">
      <Declaration><![CDATA[METHOD PUBLIC GetCommMode : PisaPulseCommMode
]]></Declaration>
      <Implementation>
        <ST><![CDATA[GetCommMode:=commMode;]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetStatus" Id="{b627c613-9025-44cd-970a-bd5106ddd8b2}">
      <Declaration><![CDATA[METHOD GetStatus : CircuitBreakerStatus
VAR_INPUT
	nChannel : UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF nChannel > 0 AND nChannel <= nNumberOfChannels THEN
	GetStatus := aStatus[nChannel];
ELSE
	GetStatus := CircuitBreakerStatus.UNKNOWN;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="ReadFromDevice" Id="{2202baeb-5622-4fa6-b490-6733897db411}">
      <Declaration><![CDATA[METHOD PRIVATE ReadFromDevice : BOOL
VAR_INPUT
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[timerPulseMeasurement(IN := PisaIO.bRX , PT:=tWatchdogTime);
	

inputFallingEdge(CLK := PisaIO.bRX);//Indicates any falling edge on the input signal 
maxTime(CLK:= timerReadPeriodMax.Q);//Indicates the max period time has elapsed

IF bResetMaxTimeFlag THEN
	timerReadPeriodMax(IN:=TRUE);
	bResetMaxTimeFlag :=FALSE;
ELSE
	timerReadPeriodMax(IN:=inputFallingEdge.Q AND NOT timerReadPeriodMax.Q, PT:= STATUS_PERIOD_DURATION);
END_IF

IF( PisaIO.bRX = TRUE AND NOT inputFallingEdge.Q AND NOT timerPulseMeasurement.Q) THEN // IF the input is high, update the running counter of the pulse duration
	tLastPulseDuration := timerPulseMeasurement.ET;	
END_IF

timerReadSequenceWatchdog(IN := inputFallingEdge.Q, PT:= tWatchdogTime);

IF (timerReadSequenceWatchdog.Q = FALSE) THEN//Our watchdog has expired
	commMode := PisaPulseCommMode.Offline;	
	ClearStoredValues();
END_IF

IF (inputFallingEdge.Q)THEN //A pulse just completed

	
	IF tLastPulseDuration >= SHORT_START_PULSE_DURATION - DRIFT_TOLERANCE THEN
		IF tLastPulseDuration >= T#155MS(*LONG_START_PULSE_DURATION - DRIFT_TOLERANCE THEN*) THEN
			commMode := PisaPulseCommMode.Unidirectional;
		ELSE
			commMode := PisaPulseCommMode.Bidirectional;
		END_IF
		
		bStartBitFound 	:= NOT bStartBitFound; // Main reset happens elsewhere. Failsafe here. Only happense every other cycle but acceptable as only a failsafe.
		ResetReadIndex();//Reset counter to prepair for next cycle 
		tLastPulseDuration :=T#0MS ;// reset the time counter so we can measure next pulses
		
	END_IF
END_IF

IF (((maxTime.Q = TRUE AND PisaIO.bRX = FALSE )) AND bStartBitFound = TRUE) THEN 
	IF timerPeriodMin.Q THEN
		nReadingChannelIndex := nReadingChannelIndex + 1;
		timerPeriodMin(IN:= FALSE, PT:=DRIFT_TOLERANCE);
	END_IF 
ELSE
	timerPeriodMin(IN:= TRUE, PT:=DRIFT_TOLERANCE);			
END_IF

IF bStartBitFound THEN // Only calculate state if we have found the start bit and thus are in the channel bits
	IF (nLastReadingChannelIndex <> nReadingChannelIndex) THEN//We have advanced to the gap period after a readin of a pulse
		
		bResetMaxTimeFlag:=TRUE;

		IF tLastPulseDuration >= DRIFT_TOLERANCE THEN //have a positive signal
			IF tLastPulseDuration >= MIN_PULSE_DURATION - DRIFT_TOLERANCE THEN //Signal large enough than smallest expected
				IF tLastPulseDuration > STATUS_DURATION - DRIFT_TOLERANCE THEN
					aStatus[nLastReadingChannelIndex]	:= CircuitBreakerStatus.TRIPPED;
				ELSIF tLastPulseDuration > MIN_PULSE_DURATION - DRIFT_TOLERANCE THEN
					aStatus[nLastReadingChannelIndex]	:= CircuitBreakerStatus.OFF;
				ELSE //should never happen
					ClearStoredValues();
				END_IF	
			ELSE//Likely indicates out of sync
				ClearStoredValues();
			END_IF
		ELSE
			IF commMode = PisaPulseCommMode.Bidirectional THEN	
				aStatus[nLastReadingChannelIndex]	:= CircuitBreakerStatus.ON;
			ELSE
				aStatus[nLastReadingChannelIndex]	:= CircuitBreakerStatus.NOTTRIPPED;
			END_IF
		END_IF
				
		tLastPulseDuration :=T#0MS ;// reset the time counter as we have recorded the measurement for this pulse
		nLastReadingChannelIndex := nReadingChannelIndex;
	END_IF

	IF nReadingChannelIndex > nNumberOfChannels THEN //End of Sequence
		bStartBitFound := FALSE;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResetAll" Id="{137c3d21-3291-4818-9502-42e505c5b017}">
      <Declaration><![CDATA[METHOD PUBLIC ResetAll : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[bBidirectionalRequested:=TRUE;
timerResetDelay(IN:= NOT timerResetDelay.Q,PT:=tWatchdogTime );

IF timerResetDelay.Q THEN
	nResetChannel :=nResetChannel+1;
END_IF

SetStatus(nChannel:=nResetChannel, eStatus:=CircuitBreakerStatus.RESET);
SetStatus(nChannel:=nResetChannel-1, eStatus:=CircuitBreakerStatus.ON);


IF nResetChannel > nNumberOfChannels THEN
	nResetChannel:=1;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResetReadIndex" Id="{e41b78c3-0cc0-4943-ad59-a1706fab07ce}">
      <Declaration><![CDATA[METHOD PRIVATE ResetReadIndex

]]></Declaration>
      <Implementation>
        <ST><![CDATA[nReadingChannelIndex :=1;
nLastReadingChannelIndex:=1;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResetWriteIndex" Id="{40736a25-8f39-4e3e-881e-ea0b9ca16940}">
      <Declaration><![CDATA[METHOD PRIVATE ResetWriteIndex
]]></Declaration>
      <Implementation>
        <ST><![CDATA[PisaIO.bTX:=FALSE;
nNextWriteChannelFlag:=TRUE;
nWriteIndex:=0;	
aCtrl[0]:=sStartBitSignal;
aCtrl[nNumberOfChannels+1]:=sStopBitSignal;
aCtrl[nNumberOfChannels+2]:=sWaitBitSignal;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetStatus" Id="{6642a64a-4e50-4f13-b203-f745ad1ed55d}">
      <Declaration><![CDATA[METHOD SetStatus
VAR_INPUT
	nChannel : UINT;
	eStatus : CircuitBreakerStatus;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF nChannel >0 AND nChannel<=nNumberOfChannels THEN
	aTargetStatus[nChannel]:=eStatus;
	IF (aStatus[nChannel] <> CircuitBreakerStatus.ON)THEN
		IF(eStatus = CircuitBreakerStatus.RESET AND commMode =  PisaPulseCommMode.Bidirectional)  THEN
			aStatus[nChannel] := CircuitBreakerStatus.RESET;
		END_IF
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="WriteToDevice" Id="{1e9decf7-4bb3-4e88-b3b1-818725582bbf}">
      <Declaration><![CDATA[METHOD PRIVATE WriteToDevice : BOOL
VAR_INPUT
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF nNextWriteChannelFlag THEN
	nTimersToComplete:=0;
	IF(aCtrl[nWriteIndex].tLeadingGap > T#0MS)THEN
		nTimersToComplete:=nTimersToComplete+1;
	END_IF
	IF(aCtrl[nWriteIndex].tHighSignal > T#0MS)THEN
		nTimersToComplete:=nTimersToComplete+1;
	END_IF
	IF(aCtrl[nWriteIndex].tTrailingGap > T#0MS)THEN
		nTimersToComplete:=nTimersToComplete+1;
	END_IF
END_IF

timerLeadingGap(IN:=nNextWriteChannelFlag, PT:=aCtrl[nWriteIndex].tLeadingGap);
timerWriteHigh(IN:= NOT timerLeadingGap.Q AND NOT nNextWriteChannelFlag, PT:=aCtrl[nWriteIndex].tHighSignal);
timerTrailingGap(IN:= NOT timerWriteHigh.Q AND NOT timerWriteHigh.Q AND NOT nNextWriteChannelFlag AND nDoneCount>0, PT:=aCtrl[nWriteIndex].tTrailingGap);

fTimer1Done(CLK:= timerLeadingGap.Q);
fTimer2Done(CLK:= timerWriteHigh.Q);
fTimer3Done(CLK:= timerTrailingGap.Q);


IF (fTimer1Done.Q OR  fTimer2Done.Q OR fTimer3Done.Q)AND NOT nNextWriteChannelFlag THEN
	nDoneCount := nDoneCount +1;
END_IF


nNextWriteChannelFlag:=FALSE;
IF nDoneCount >= nTimersToComplete  THEN

	nDoneCount:=0;
	nWriteIndex := nWriteIndex + 1;
	nNextWriteChannelFlag:=TRUE;
	
	
	IF(nWriteIndex>0 AND nWriteIndex <nNumberOfChannels+1) THEN
		//Update any target values. Won't execute till next cycle
		CASE aTargetStatus[nWriteIndex] OF 
		CircuitBreakerStatus.OFF, CircuitBreakerStatus.TRIPPED:
			aCtrl[nWriteIndex]:=sOffSignal;
		CircuitBreakerStatus.ON:
			aCtrl[nWriteIndex]:=sOnSignal;
		CircuitBreakerStatus.RESET :
			aCtrl[nWriteIndex]:=sResetSignal;
		ELSE // Default to ON for UNKNOWN or NOTTRIPPED
			aCtrl[nWriteIndex]:=sOnSignal;
		END_CASE;
	END_IF	
END_IF

IF(nWriteIndex >nNumberOfChannels + WRITE_PERIODS_AFTER_DATA) THEN  
		ResetWriteIndex();
END_IF

PisaIO.bTX:=timerWriteHigh.Q;//Write to digital output]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>