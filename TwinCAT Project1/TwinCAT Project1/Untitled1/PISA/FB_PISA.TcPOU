<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.15">
  <POU Name="FB_PISA" Id="{fcd1d659-8ade-4890-bc41-6e29b3b0778a}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_PISA
VAR_INPUT
	 bStart	: BOOL;
	 bBidirectional	: BOOL;
END_VAR
VAR CONSTANT
	//Constants as defined in Pulse Pisa Manuals
    MAX_NUMBER_OF_CHANNELS : USINT            := 8;         //Theoritical max channels offered by Pulse is 64. Setting to 8 for now as we are unlikely to go beyond 8
	STANDARD_NUMBER_OF_CHANNELS : USINT       :=4;    //TODO make variable on init
	
	
	SHORT_START_PULSE_DURATION : TIME := T#150MS;
	LONG_START_PULSE_DURATION : TIME  := T#200MS;
	
	DRIFT_TOLERANCE : TIME        := T#15MS;//cCycleTime *2;cGapTime : TIME :=T#100MS;
	STATUS_DURATION: TIME        := T#100MS;
	NOMINAL_PERIOD_DURATION: TIME := T#200MS;
	STATUS_PERIOD_DURATION: TIME        := T#190MS;//gapTime + statusTime; Nominally 200ms but practically 200ms - CycleTime. to ensure trigger before end of period.
	STATUS_MIN_PERIOD_DURATION:TIME  := T#60MS;
	
	SEQUENCE_WATCHDOG_TIME :TIME := T#3000MS;
	
	

	CYCLE_TIME : TIME := T#10MS;//TODO update this programatically on FB init.
	
	
END_VAR

VAR
	

	timerReadSequenceWatchdog : TOF;
	

	PisaIO : PISA_IO; // Struct for mapping to the actual IO Hardware
	commMode : PisaPulseCommMode := PisaPulseCommMode.Offline;
	
	tMaxTransmitSequence: TIME;
	tMaxRecieveSequence: TIME;
	
	//Variables for Reading
	aStatus : ARRAY[1..MAX_NUMBER_OF_CHANNELS] OF CircuitBreakerStatus := [MAX_NUMBER_OF_CHANNELS(CircuitBreakerStatus.UNKNOWN)];
	aTargetStatus : ARRAY[1..MAX_NUMBER_OF_CHANNELS] OF CircuitBreakerStatus := [MAX_NUMBER_OF_CHANNELS(CircuitBreakerStatus.UNKNOWN)];
	
	bStartBitFound : BOOL;//Indicateds the falling edge of the start bit has been found. (we are reading channels)
	tStartTimeDuration	: TIME ; // The expected start bit udration variable based on bi or uni directional communication. 
	nReadingChannelIndex	: USINT := 0 ; //The current channel number as determined by time or falling edges in the data
	nLastReadingChannelIndex :USINT :=0; //A lag behind value of the channel for correct array index because saving of channel data happends in the first time slice of the next channel 
	nNumberOfChannels : USINT := STANDARD_NUMBER_OF_CHANNELS;
	tLastPulseDuration : TIME; //Store the elapsed time. 
	
	timerPulseMeasurement :TON;
	timerReadPeriodMax : TP;
	timerPeriodMin :TON;
		
	inputFallingEdge: F_TRIG;
	maxTime: F_TRIG;//Indicates the maximum time of a channel has been hit
	bResetMaxTimeFlag: BOOL:=FALSE; //Used to indicate the max pulse timer needs to be reset NEXT cycle. Can't happen this cycle or Q will not trigger. 

	//Variables for Writing
	aCtrl : ARRAY[0..MAX_NUMBER_OF_CHANNELS+1] OF PULSE:= [(MAX_NUMBER_OF_CHANNELS+2)(sOnSignal)];
	
	
	timerWriteTotal : TON;

	tDataPeriodDuration: TIME;

	
	fbWaitQFalling: F_TRIG;
	fbWriteQFalling: F_TRIG;
	fbDoneTrigLow: F_TRIG;
	fbDoneTrigHigh: F_TRIG;
	timerWritePeriodMax : TP;
	
	
	timerWriteLow : NTP; //TODO-NIKO See if this can be better rewritten to no use my strange extended timer. Or clean up the timer. should add unit test first as changing it breaks functionality currently
	timerWriteHigh : NTP;
	
	bResetMaxWriteTimeFlag: BOOL;
	bMessageComplete : BOOL;
	pulseToWrite: PULSE;
	bNextFlag : BOOL:=TRUE;
	nWriteIndex : USINT;
	bWritingValues :BOOL;
		nDoneCount:USINT:=0;
		
		nTimersToComplete: USINT :=0;
		
	tLowWriteDuration:TIME;
	tHighWriteDuration:TIME;
	
	
	
	
		//Command Durations
	CMD_GAP_DURATION: TIME := T#95MS; //Nominal 100ms
	CMD_START_DURATION: TIME    := T#140MS; //Nominal 150ms
	CMD_RESET_LOW_DURATION: TIME    := T#100MS;//Nominal 100ms
	CMD_RESET_HIGH_DURATION: TIME    := T#95MS;//Nominal 100ms
	CMD_OFF_DURATION: TIME      := T#45MS;//Nominal 50ms
	CMD_STOP_GAP_DURATION : TIME := T#150MS;//Nominal 150ms
	CMD_STOP_DURATION: TIME     := T#100MS;//Nominal 100ms
	CMD_END_DURATION: TIME   := T#95MS;//Nominal 100ms
	CMD_WRITE_DURATION : TIME := T#195MS;//Nominal 200ms
	CMD_WAIT_DURATION : TIME := T#5000MS;//Nominal 50ms
	
	
	CMD_WRITE_OFFSET : TIME := T#1MS;
	
	
    sStartBitSignal : PULSE := (tLow := T#0MS, tHigh := CMD_START_DURATION);
	sResetSignal : PULSE := (tLow := CMD_RESET_LOW_DURATION, tHigh := CMD_RESET_HIGH_DURATION);
	sOnSignal : PULSE := (tLow := CMD_WRITE_DURATION, tHigh := T#0MS);
	sOffSignal : PULSE := (tLow := CMD_GAP_DURATION, tHigh := CMD_OFF_DURATION);
	sStopBitSignal : PULSE := (tLow := T#45MS, tHigh := CMD_END_DURATION);
	sWaitBitSignal : PULSE := (tLow := CMD_WAIT_DURATION, tHigh := T#0MS);
	//Constants of our PLC
	tTotalWriteTime: TIME;
	tDataWriteTime: TIME;
	tStartWriteTime:TIME;
	tNotStopBitWriteTime:TIME;
	tDesiredStopGap:TIME;
	
	tEndGapDuration :TIME:=T#50MS;
	tTotalExpectedWriteDuration:TIME:=T#1200MS;//todo set programatically based on channel count
	tTotalBitExpectedWriteDuration:TIME:=tTotalExpectedWriteDuration-tEndGapDuration;//todo set programatically based on channel count
	tAdjustedStopBitGap:TIME:=T#45MS;

	tMysteryTrim:TIME:=T#100MS;
	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF bStart THEN
	
	CalculateTimes();
	
	ReadFromDevice();
	
	IF bBidirectional THEN
		WriteToDevice();
	ELSE
		ResetWriteIndex();
	END_IF
	
	
	
	
	
	tTotalWriteTime:=CalculateWiteBitDuration(nStartBit:=0,nEndBit:=5);
	tDataWriteTime:=CalculateWiteBitDuration(nStartBit:=1,nEndBit:=4);
	tStartWriteTime:=CalculateWiteBitDuration(nStartBit:=0,nEndBit:=0);
	tNotStopBitWriteTime:=CalculateWiteBitDuration(nStartBit:=0,nEndBit:=4);
	
	tAdjustedStopBitGap:=tTotalBitExpectedWriteDuration-tNotStopBitWriteTime-sStopBitSignal.tHigh -tMysteryTrim;
	sStopBitSignal.tLow:=tAdjustedStopBitGap;
	
	
	
ELSE// Program not running.
	ClearStoredValues();
END_IF]]></ST>
    </Implementation>
    <Method Name="CalculateTimes" Id="{81049bee-aa31-48e1-9345-df471dcf9637}">
      <Declaration><![CDATA[METHOD PRIVATE CalculateTimes

]]></Declaration>
      <Implementation>
        <ST><![CDATA[

tMaxTransmitSequence:= SHORT_START_PULSE_DURATION + (NOMINAL_PERIOD_DURATION * nNumberOfChannels)+CMD_STOP_GAP_DURATION +CMD_STOP_DURATION+T#100MS;
//Nominally 1200MS for 4 chanels	
tDataPeriodDuration := NOMINAL_PERIOD_DURATION * nNumberOfChannels;



//Nominally 200MS per channel	
IF commMode= PisaPulseCommMode.Unidirectional THEN
	tStartTimeDuration	:= LONG_START_PULSE_DURATION;
	tMaxRecieveSequence := LONG_START_PULSE_DURATION + (NOMINAL_PERIOD_DURATION * nNumberOfChannels)  + STATUS_DURATION;
	//Nominally 1100MS for 4 chanels
ELSE
	tStartTimeDuration	:= SHORT_START_PULSE_DURATION;
	tMaxRecieveSequence := SHORT_START_PULSE_DURATION + (NOMINAL_PERIOD_DURATION * nNumberOfChannels)  + STATUS_DURATION;
	//NOMINALLY 1050MS for 4 chanels	
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="CalculateWiteBitDuration" Id="{521a4c92-6139-4c79-bb7e-22d786562bc0}">
      <Declaration><![CDATA[METHOD PRIVATE CalculateWiteBitDuration : TIME
VAR_INPUT
	nStartBit:USINT;
	nEndBit :USINT;
END_VAR

VAR
	i: INT;
	tRunningTotal:TIME:=T#0MS;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i := nStartBit TO nEndBit DO
    tRunningTotal:=tRunningTotal + aCtrl[i].tLow + aCtrl[i].tHigh;
END_FOR;

CalculateWiteBitDuration:=tRunningTotal;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="ClearStoredValues" Id="{8c872f6e-f6ce-4ed1-8772-ffa97afe5b3d}">
      <Declaration><![CDATA[METHOD PRIVATE ClearStoredValues
VAR_INPUT
END_VAR
VAR
	i : INT;//array index
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i := 1 TO nNumberOfChannels DO
	aStatus[i] := CircuitBreakerStatus.UNKNOWN; // Wipe out the array as we are in an unexpected state so no recorded values are guarenteed to be correct. 
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{9b52ece2-d8dc-409f-8275-86ed0ed48b59}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[aCtrl[0]:=sStartBitSignal;
aCtrl[nNumberOfChannels+1]:=sStopBitSignal;]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetCommMode" Id="{0c35d0de-ab17-4237-a989-bcb0a8d52a88}">
      <Declaration><![CDATA[METHOD PUBLIC GetCommMode : PisaPulseCommMode
]]></Declaration>
      <Implementation>
        <ST><![CDATA[GetCommMode:=commMode;]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetStatus" Id="{b627c613-9025-44cd-970a-bd5106ddd8b2}">
      <Declaration><![CDATA[METHOD GetStatus : CircuitBreakerStatus
VAR_INPUT
	nChannel : UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF nChannel > 0 AND nChannel <= nNumberOfChannels THEN
	GetStatus := aStatus[nChannel];
ELSE
	//todo error
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetTripped" Id="{8ec2a531-3dec-441a-a5aa-8cf2cebb1674}">
      <Declaration><![CDATA[METHOD PUBLIC GetTripped : BOOL
VAR_INPUT
	nChannel : USINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF nChannel > 0 AND nChannel <= nNumberOfChannels THEN
	GetTripped := aStatus[nChannel] = CircuitBreakerStatus.TRIPPED;
ELSE
	//todo error
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="ReadFromDevice" Id="{2202baeb-5622-4fa6-b490-6733897db411}">
      <Declaration><![CDATA[METHOD PRIVATE ReadFromDevice : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[timerPulseMeasurement(IN := PisaIO.bRX , PT:=tStartTimeDuration+DRIFT_TOLERANCE);
	



inputFallingEdge(CLK := PisaIO.bRX);//Indicates any falling edge on the input signal 
maxTime(CLK:= timerReadPeriodMax.Q);//Indicates the max period time has elapsed

IF bResetMaxTimeFlag THEN
	timerReadPeriodMax(IN:=TRUE);
	bResetMaxTimeFlag :=FALSE;
ELSE
	timerReadPeriodMax(IN:=inputFallingEdge.Q AND NOT timerReadPeriodMax.Q, PT:= STATUS_PERIOD_DURATION);
END_IF



IF( PisaIO.bRX = TRUE AND NOT inputFallingEdge.Q AND NOT timerPulseMeasurement.Q) THEN // IF the input is high, update the running counter of the pulse duration
	tLastPulseDuration := timerPulseMeasurement.ET;	
END_IF

timerReadSequenceWatchdog(IN := inputFallingEdge.Q, PT:= SEQUENCE_WATCHDOG_TIME);

IF (timerReadSequenceWatchdog.Q = FALSE) THEN//Our watchdog has expired
	commMode := PisaPulseCommMode.Offline;	
	ClearStoredValues();
END_IF


IF (inputFallingEdge.Q)THEN //A pulse just completed
	timerReadPeriodMax(IN:=FALSE);//End of period triggers end of time counter resets time to 0 
	
	IF tLastPulseDuration >= SHORT_START_PULSE_DURATION - DRIFT_TOLERANCE THEN
		IF tLastPulseDuration >= T#155MS(*LONG_START_PULSE_DURATION - DRIFT_TOLERANCE THEN*) THEN
			commMode := PisaPulseCommMode.Unidirectional;
		ELSE
			commMode := PisaPulseCommMode.Bidirectional;
		END_IF
		
		bStartBitFound 	:= NOT bStartBitFound; // Main reset happens elsewhere. Failsafe here. Only happense every other cycle but acceptable as only a failsafe. 
		tLastPulseDuration :=T#0MS ;// reset the time counter so we can measure next pulses
		
	END_IF
END_IF

IF ((inputFallingEdge.Q = TRUE OR (maxTime.Q = TRUE AND PisaIO.bRX = FALSE )) AND bStartBitFound = TRUE) THEN 
	IF timerPeriodMin.Q THEN
		nReadingChannelIndex := nReadingChannelIndex + 1;
		timerPeriodMin(IN:= FALSE, PT:=DRIFT_TOLERANCE);
	END_IF 
ELSE
	timerPeriodMin(IN:= TRUE, PT:=DRIFT_TOLERANCE);			
END_IF

IF bStartBitFound THEN // Only calculate state if we have found the start bit and thus are in the channel bits
	IF (nLastReadingChannelIndex <> nReadingChannelIndex) THEN//We have advanced to the gap period after a readin of a pulse
		
		bResetMaxTimeFlag:=TRUE;
		
		
		
		
		IF tLastPulseDuration >= DRIFT_TOLERANCE THEN //have a positive signal
			IF tLastPulseDuration >= CMD_STOP_DURATION - DRIFT_TOLERANCE THEN //Signal large enough than smallest expected
				IF tLastPulseDuration > STATUS_DURATION - DRIFT_TOLERANCE THEN
					aStatus[nLastReadingChannelIndex]	:= CircuitBreakerStatus.TRIPPED;
				ELSIF tLastPulseDuration > CMD_STOP_DURATION - DRIFT_TOLERANCE THEN
					aStatus[nLastReadingChannelIndex]	:= CircuitBreakerStatus.OFF;
				ELSE //should never happen
					ClearStoredValues();
				END_IF	
			ELSE//Likely indicates out of sync
				ClearStoredValues();
			END_IF
		ELSE	
			aStatus[nLastReadingChannelIndex]	:= CircuitBreakerStatus.ON;
		END_IF
		
		
		
		
		(*
		
		IF nLastReadingChannelIndex > 0 AND nLastReadingChannelIndex <= nNumberOfChannels THEN
			IF tLastPulseDuration > CYCLE_TIME AND tLastPulseDuration <= CMD_STOP_DURATION + CYCLE_TIME THEN
				aStatus[nLastReadingChannelIndex]	:= CircuitBreakerStatus.OFF;
			ELSIF tLastPulseDuration > CMD_STOP_DURATION THEN
				aStatus[nLastReadingChannelIndex]	:= CircuitBreakerStatus.Tripped;
			ELSE
				aStatus[nLastReadingChannelIndex]	:= CircuitBreakerStatus.ON;
			END_IF
		END_IF
		
		*)
		
		tLastPulseDuration :=T#0MS ;// reset the time counter as we have recorded the measurement for this pulse
		nLastReadingChannelIndex := nReadingChannelIndex;
	END_IF

	IF nReadingChannelIndex > nNumberOfChannels THEN //End of Sequence
		bStartBitFound := FALSE;
		ResetReadIndex();//Reset counter to prepair for next cycle
	END_IF
ELSE//!StartBitFound
	IF nReadingChannelIndex > 0 THEN//We do not expect to ever be in this state. Indicates the channel number failed to increment. Likely due to a timer failing to reset or the max period timers didn't expire before the next start bit was found;
		ClearStoredValues();//Clear out our saved cb state data as it is likely incorrect due to above condition
	END_IF
	ResetReadIndex();//Reset counter to prepair for next cycle
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResetAll" Id="{137c3d21-3291-4818-9502-42e505c5b017}">
      <Declaration><![CDATA[METHOD PUBLIC ResetAll : BOOL
VAR_INPUT
	PT :TIME;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResetReadIndex" Id="{e41b78c3-0cc0-4943-ad59-a1706fab07ce}">
      <Declaration><![CDATA[METHOD PRIVATE ResetReadIndex

]]></Declaration>
      <Implementation>
        <ST><![CDATA[nReadingChannelIndex :=0;
nLastReadingChannelIndex:=0;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResetWriteIndex" Id="{40736a25-8f39-4e3e-881e-ea0b9ca16940}">
      <Declaration><![CDATA[METHOD PRIVATE ResetWriteIndex
]]></Declaration>
      <Implementation>
        <ST><![CDATA[PisaIO.bTX:=FALSE;
bNextFlag:=TRUE;
nWriteIndex:=0;	
aCtrl[0]:=sStartBitSignal;
aCtrl[nNumberOfChannels+1]:=sStopBitSignal;
aCtrl[nNumberOfChannels+2]:=sWaitBitSignal;
bWritingValues:=FALSE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetStatus" Id="{6642a64a-4e50-4f13-b203-f745ad1ed55d}">
      <Declaration><![CDATA[METHOD SetStatus
VAR_INPUT
	nChannel : UINT;
	eStatus : CircuitBreakerStatus;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF nChannel >0 AND nChannel<=nNumberOfChannels THEN
	aTargetStatus[nChannel]:=eStatus;
	
	IF(eStatus = CircuitBreakerStatus.RESET) THEN
		aStatus[nChannel] := CircuitBreakerStatus.RESET;
	END_IF
	//TODO Error handeling? Return success fail? 
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="WriteToDevice" Id="{1e9decf7-4bb3-4e88-b3b1-818725582bbf}">
      <Declaration><![CDATA[METHOD PRIVATE WriteToDevice : BOOL
VAR_INPUT
END_VAR
   
VAR CONSTANT
 TIMERS_PER_PULSE:USINT:=2;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF bNextFlag THEN
	nTimersToComplete:=0;
	IF(aCtrl[nWriteIndex].tLow > T#0MS+CMD_WRITE_OFFSET)THEN
		nTimersToComplete:=nTimersToComplete+1;
		tLowWriteDuration:= aCtrl[nWriteIndex].tLow + CMD_WRITE_OFFSET;
	ELSE
		tLowWriteDuration:=T#0MS;
	END_IF
	
	IF(aCtrl[nWriteIndex].tHigh > T#0MS+CMD_WRITE_OFFSET)THEN
		nTimersToComplete:=nTimersToComplete+1;
		tHighWriteDuration:= aCtrl[nWriteIndex].tHigh + CMD_WRITE_OFFSET;
	ELSE
		tHighWriteDuration:=T#0MS;
	END_IF
END_IF

//Gap Timer
timerWriteLow(IN:=bNextFlag, PT:=tLowWriteDuration);
fbDoneTrigLow(CLK:= (timerWriteLow.Q));
//fbWaitQFalling(clk:=timerWriteLow.Q);
//Pulse Timer
timerWriteHigh(IN:= NOT timerWriteLow.Q AND NOT bNextFlag, PT:=tHighWriteDuration);
//fbWriteQFalling(clk:=timerWriteHigh.Q);
fbDoneTrigHigh(CLK:= (timerWriteHigh.Q));

//fbDoneTrig(CLK:= (timerWriteHigh.bDone OR timerWriteLow.bDone));

IF fbDoneTrigLow.Q  THEN
	nDoneCount := nDoneCount +1;
END_IF

IF  fbDoneTrigHigh.Q THEN
	nDoneCount := nDoneCount +1;
END_IF




bNextFlag:=FALSE;
IF nDoneCount >= nTimersToComplete  THEN
	timerWriteLow.Reset();
	timerWriteHigh.Reset();
	nDoneCount:=0;
	nWriteIndex := nWriteIndex + 1;
	bNextFlag:=TRUE;
	
	
	IF(nWriteIndex>0 AND nWriteIndex <nNumberOfChannels+1) THEN
		//Update any target values. Won't execute till next cycle
		bWritingValues:=TRUE;
		CASE aTargetStatus[nWriteIndex] OF 
		CircuitBreakerStatus.OFF, CircuitBreakerStatus.TRIPPED:
			aCtrl[nWriteIndex]:=sOffSignal;
		CircuitBreakerStatus.ON, CircuitBreakerStatus.UNKNOWN :
			aCtrl[nWriteIndex]:=sOnSignal;
		CircuitBreakerStatus.RESET :
			aCtrl[nWriteIndex]:=sResetSignal;
		END_CASE;
	ELSE
		bWritingValues:=FALSE;
	END_IF
	
	
END_IF

IF(nWriteIndex >nNumberOfChannels + 2) THEN //todo fix magic number 2 because start and stop bits 
		ResetWriteIndex();
END_IF


PisaIO.bTX:=timerWriteHigh.Q;]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>